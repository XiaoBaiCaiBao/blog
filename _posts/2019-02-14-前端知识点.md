---
title: 前端知识点
layout: post
categories: ''
tags: ''
---
#### 2019.2.12

## |**页面布局**|

- 《前端跳槽面试必备技巧》（3-1 3-2 页面布局）
- 三栏布局题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为 300px，中间自适应。

### 解题思路

见 layout.html

### 知识点总结

六种布局方案的实现方式，关键点，导致的问题，解决方式，优缺点

**float**

- **实现方式**
  - 目前已知两种。
  1. 方式一：子元素全部左浮动，元素顺序左中右；
  2. 方式二：左元素左浮动，右元素右浮动，中间元素自动上顶，元素顺序左右中（顺序很重要，如果左中右的顺序会如何？）。
- **关键点**
  1. float 后的元素具有包裹性，如果不给定宽度，则元素宽度由内部内容决定。
  2. float 后的元素脱离文档流，之后的元素起始位置会覆盖 float 元素，但之后元素里面的内容会让出 float 元素从而不被遮挡。
  3. 如果所有子元素都 float，会导致父元素高度塌陷问题，进而导致父元素后面的元素的 margin 问题等。需清除浮动。具体方式：
     - position 不为 static 或 relative
     - float 不为 none
     - overflow 不为 visible，可为 auto,scroll,hidden
     - display 为 inline-block,table-cell,table-caption
- **优缺点**
  - 优点：浏览器兼容性好
  - 缺点：？

**inline-block**

- **实现方式**
  - 子元素全部 inline-block，左右元素宽度 300px，中间元素 calc
- **关键点**
  - 注意解决子元素之间因代码空格换行导致的间距问题，父元素 font-size 设置为 0，子元素恢复 font-size
- **导致问题及解决方式**
  - 垂直居中问题,中间部分元素垂直方向位置：内部内容底部和两侧元素底部对齐？？？
- **优缺点**

### 待解决问题

1. float 的深刻理解，清除浮动等
2. inline-block 垂直位置问题

---

#### 2019.2.13

## |**CSS 盒模型**|

- 《前端跳槽面试必备技巧》（3-3 3-4 CSS 盒模型）
- 题目：解释 CSS 盒模型。

### 解题思路

标准模型和 IE 模型

### 知识点总结

啥

**inline-block**

- **实现方式**
- **关键点**
- **导致问题及解决方式**
- **优缺点**

### 待解决问题

---

## |**DOM 事件**|

- 《前端跳槽面试必备技巧》（3-6 3-7 DOM 事件）
- 题目：

---

## |**类型转换**|

- 《前端跳槽面试必备技巧》（3-8 类型转换）
- 题目：

---

#### 2019.2.14

## |**对象与原型**|

> imooc 《javascript 深入浅出》 （4-1 4-2 对象 原型链）。  
> 这两节讲的比较清楚，可以再看看。里面的图记住。

### _对象_

- **知识点**

  1. 对象中的属性是**无序的**，且每个属性都有一个**字符串**key
  2. 每个属性都有一些标签（writable enumerable configurable value），和 get/set 方法
  3. 每个对象有一个原型属性[[proto]]。下方代码中 obj.z 值为 1。访问对象中的属性时，如果没有在对象本身的属性中找到，会继续沿着原型链向上寻找。

  ```
  function foo(){}
  foo.prototype.z = 3;
  var obj = new foo();
  ```

  4. 对象还有一个[[class]]标签来表示它是哪个种类的，一个[[extensible]]来表示它是否允许增加新的属性
  5. 创建对象的方式
     - 对象字面量
     - new/原型链
     - Object.create()
  6. 原型链
     - delete obj.z 删除对象上的属性，不会影响原型链
  7. Object.create({})
     - 是系统内置函数，参数一般是对象。结果返回一个对象，并使对象的原型指向这个参数。

- **待解决问题**
  1. 什么时候输出 undefined 什么时候报错 not defined
  2. var ob = new function();
     ob 是对象？函数里面的行为会立即执行？
  3. 原型链指向问题。
  4. 对象属性检测。重新看看视频。

## |**对象与原型**|

> 《前端跳槽面试必备技巧》（3-10 3-11 原型链）

- **原型链**
  1. 创建对象有几种方法
  2. 什么是原型，构造函数，实例，原型链
     - 生成的对象就是一个实例
     - new 后面的函数是构造函数。构造函数也是普通函数，放在 new 后面就成了构造函数。构造函数使用 new 运算符来生成一个实例。
     - 原型链的指向，实例对象构造函数原型对象间的指向图记清楚。
     - 构造函数的 prototype 属性是用来将通用属性和方法传递给实例对象的。
     - 只有函数才有 prototype 属性，对象没有。因为对象不能作为构造函数被 new，所以不传递属性和方法，没必要有 prototype。
  3. instanceof 的原理
     - instanceof 的两边一边是实例对象的[[proto]]，另一边是构造函数的 prototype。
     - 只要是原型链上的构造函数，都会返回 true。
     - 如果要确认是否是直接构造函数，而不是原型链上的构造函数，需使用（实例对象.[[proto]].constructor == 构造函数）来判断。
  4. new 运算符
- **待解决问题**
  1. new 运算符还没看懂

---

#### 2019.2.15

## |**对象**|

> imooc 《javascript 深入浅出》 （第 4 章）

### _属性操作（4-3）_

- **读写对象属性**

  - 读：
    - obj.x(推荐使用)
    - obj.\['字符串 key'\](需要拼接等场景)
    - `for (p in obj){ console.log(obj[p]) }`。这种方式会把原型链上的属性遍历出来，并且顺序不确定。
    ```
    var obj = {a:2, b:5};
    for(var x in obj){
      console.log(x); // a, b
      console.log(obj[x]); // 2, 5
    }
    ```

- **属性读写-异常**

  - 读取不存在的属性会返回 undefined，读取或赋值给不存在的属性的属性会报错。

  ```
  var obj = {x:1};
  obj.y; // undefined
  var yz = obj.y.z; // TypeError: Cannot read property 'z' of undefined
  obj.y.z = 2; // TypeError: Cannot set property 'z' of undefined
  ```

  - 操作之前进行检测

  ```
  var yz;
  if(obj.y) {
    yz = obj.y.z;
  }
  ```

  - 巧用&&运算符规则

  ```
  var yz = obj && obj.y && obj.y.z;
  ```

- **删除属性**

  ```
  var person = {age: 28, title: 'fe'};
  delete person.age; // true
  delete person['title']; // true
  person.age; // undefined
  delete person.age; // true。重复删除不存在的属性，由于属性已经不存在所以仍返回true。
  ```

  ```
  delete Object.prototype; // false

  var descriptor = Object.getOwnPropertyDescriptor(Object, 'prototype'); // 获取对象中的所有标签，第一个参数是要查看的对象，第二个参数是要检测的属性。descriptor是属性的描述器对象。

  descriptor.configurable; // false。是否可配置。

  ```

  - var 定义的全局或局部变量不能被 delete，会返回 false。
  - 函数声明也不能被 delete。
  - 隐式定义变量可以被删除。不推荐。

  ```
  onNo = 1;
  window.ohNo; // 1;
  delete onNo; // true
  ```

  - evalue？里面定义的变量可以被删除。？这句话没听清，没细讲。

- **属性检测**

  ```
  // 构造一个对象并添加属性
  var cat = new Object;
  cat.legs = 4;
  cat.name = "Kitty";

  // in操作符来检测。会沿原型链向上查找。
  'legs' in cat; // true
  'abc' in cat; // false
  'toString' in cat; // true, inherited property.

  // hasOwnProperty('key')。只检查对象本身。
  cat.hasOwnProperty('legs'); // true
  cat.hasOwnProperty('toString'); // false

  // propertyIsEnumerable。检查属性是否可枚举。原型链上的大部分属性可枚举都是false，所以console对象时不会显示出来。
  cat.propertyIsEnumerable('legs'); // true
  cat.propertyIsEnumerable('toString'); // false

  ```

  - 自定义枚举标签

  ```
  Object.defineProperty(object name, 'property name', {enumerable: false(默认也是false), value: 1000}); // 通过这种方式定义的属性的enumerable如果不设置，默认为false。其他方式如字面量定义的对象属性默认enumerable是true。

  ```

  - 检测写法

  ```
  // 判断属性是否存在
  if(cat && cat.legs){
    cat.legs *= 2;
  }

  // undefined == null（两个等号下）
  if(cat.legs != undefined){
    // !== undefined or !== null
  }

  // 只处理不等于undefined的情况，使用严格等于
  if(cat.legs !== undefined){
    // only if cat.legs is not undefined
  }
  ```

- **属性枚举**
  - 不可枚举属性在对象 for in 遍历时不会显示
  - 只处理对象上的属性，不处理原型链上的属性，可增加 obj.hasOwnProperty(key)判断

### _get/set 方法（4-4）_

- 属性的 getter/setter 方法

```
var man = {
  weibo: '@Bosn',
  $age: null, // $开头不想暴露给外面
  get age() {
    if (this.$age == undefined) { // null值也会进入此分支
      return new Date().getFullYear() - 1988;
    } else {
      return this.$age;
    }
  },
  set age(val) {
    val = +val; // '+'可将值转化为数字类型
    if (!isNaN(val) && val > 0 && val < 150) {
      this.$age = +val;
    } else {
      throw new Error('Incorrect val =' + val);
    }
  }
}
console.log(man.age); //27
man.age = 100;
console.log(man.age); //100
man.age = 'abc'; //error:Incorrect val = NaN
```

- get/set 方法与原型链
  - 如果通过 obj.z 这种方式给对象属性赋值，如果该原型链上存在 z 的 get/set 方法，那么赋值不会成功，而是会走原型链的 get/set 方法。这种情况可通过 Object.defineProperty(obj, 'z', {value: 100, configurable: true});定义属性来解决。
  - 属性标签 writable 默认为 false，所以如果设置属性时不设置 writable，并且原型链上有这个属性，那么之后修改这个属性就不能成功。

### _属性标签（4-5）_

- 获取属性标签
  Object.getOwnPropertyDescriptor({pro: true}, 'pro');
  通过字面量方式定义的对象的 writable,enumerable,configurable 标签默认值均为 true。
- 设置属性标签
  ```
  Object.defineProperty(person, 'name',{
    writable: true/false
    enumerable: true/false // 设置false后，Object.keys(person);就不会显示
    configurable: true/false
    value: ''
  })
  ```
  设置多个属性,以及增加 get/set 方法
  ```
  Object.defineProperties(person, {
    title: {
      value: 'fe',
      enumerable: true
    },
    salary: {
      value: 50000,
      enumerable: true,
      writable: true
    },
    //...,
    luck: {
      get: function () {
        return Math.Random() > 0.5 ? 'good' : 'bad';
      }
    },
    promote: {
      set: function (level) {
        this.salary *= 1 + level * 0.1;
      }
    }
  })
  ```
- configurable 和 writable 为 true 或 false 的情况组合下属性的权限表格？？？

### _对象标签，对象序列化（4-6）_

- **对象标签**

  - 原型标签：\_\_proto\_\_ [[proto]]
  - class 标签：表示对象是哪个类型。可间接通过 Object.prototype.toString 来获取 class。
  - extensiable 标签表示对象是否可扩展。
    - Object.isExtensible(obj); //检测是否可扩展
    - Object.preventExtensions(obj); //禁止扩展
    - Object.seal(obj); //seal 方法会将对象的 configurable 标签设置为 false。Object.isSealed(obj);// 判断对象是否被 seal
    - Object.freeze(obj); //writable,configurable 都被设置为 false。Object.isFrozen(obj); //判断对象是否被冻结。
    - 上述方法均不会对原型链上的对象产生影响。如果改变原型链通过 Object.prototype.?（没听清）来拿到原型链的方法，来遍历原型链并进行操作。

- **序列化**

  - JSON.stringify(obj); //返回对象序列化后的字符串
    - 如果对象属性值为 undefined，那么序列化后的字符串中不会出现该属性。
    - 如果属性值为 NaN 或 Infinity，那么序列化时会被转化为'null'
    - 如果是 Date 类型，会被转化为 UTC 的格式
    ```
    obj = {val:undefined, a:NaN, b:Infinity, c:new Date()};
    // "{"a":null,"b":null,"c":"2019-02-15T09:33:35.728Z"}"
    ```
  - JSON.parse('{"x":1}'); //反序列化，将字符串转化为 js 对象。

    - 属性必须用双引号引起来。

  - 自定义序列化
    ```
    var obj = {
      x: 1,
      y: 2,
      o: {
        o1: 1,
        o2: 2,
        toJSON: function () {
          return this.o1 + this.o2;
        }
      }
    }
    JSON.stringify(obj); //"{"x":1,"y":2,"o":3}"
    ```
    - 'toJSON'属性，修改后面函数

- **其它对象方法**

  - toString()

    - `var obj = {x:1, y:2};`
    - `obj.toString();` // "[object Object]"
    - `obj.toString = function(){return this.x + this.y};` //自定义 toString()
    - `"Result" + obj;` //"Result 3", by toString.（加号运算符右侧 obj 会自动调用 toString()，所以返回 3）
    - `+obj;` //3, from toString

  - valueOf() 把对象转换为基本类型

    - `obj.valueOf = function(){return this.x + this.y + 100};` // 103, from valueOf`
    - `"Result" + obj;` // still "Result 103"

  - 当 toString()和 valueOf()都存在时，一元运算符'+'和作为拼接字符串使用的'+'，都会尝试把对象转换为基本类型，会先找 valueOf()。如果 valueOf()返回的结果是基本类型，那么就以 valueOf()的结果作为结果；如果 valueOf()不存在或者返回的是对象就会去找 toString()，如果不存在或者是返回对象，那么就会报错。
  - 很少自己调用 toString()和 valueOf(),做一些操作时，js 解释器会自动调用。

### _第 4 章总结_

- 对象的结构
- 创建对象
- 属性操作
- getter setter
- 属性标签 writable enumerable configurable value
- 对象标签 [[proto]] extensiable class
- 序列化
- 对象方法

---

#### 2019.2.16

## |**数组**|

> imooc 《javascript 深入浅出》 （第 5 章）

### _创建数组（5-1）_

- **数组概述**
  - 数组长度限制[0,2^23-1]
- **创建数组**
  - 字面量
    - 特殊情况，不推荐（可读性差，老 IE 兼容性问题）：
      - `var commasArr1 = [1,,2];`//1, undefined,2 如果有空位会被解释为 undefined
      - `var commasArr2 = [,,];`//undefined \* 2 最后一个多余的逗号会被忽略掉
  - Array 构造器 new Array()。new 关键字可以省略，var a = Array()也可。
    - 参数是数字。确定数组的长度。
    - 参数直接赋值。
- **数组元素读写**
  - 通过索引即数组下标来访问数组元素
  - 可以动态添加数组元素，进而改变数组长度 arr.length
  - `delete arr[0];arr[0];`//undefined。执行 delete 不会改变数组长度。
- **数组元素增删**
  - 数组长度是动态的，无需指定大小
  - 增加
    - `arr[i]`
    - `arr.push(x);` // 尾部增加元素
    - `arr[arr.length];` // 尾部增加元素
    - `arr.unshift(x);` // 头部增加元素
  - 删除
    - `delete arr[x];` //将 x 下标元素修改为 undefined。
      - delete 后，`i in arr;` 返回结果为 false,这里 i 是数组下标，而不是具体的元素值，使用元素值非数组下标会返回 false。
      - 如果不使用 delete，直接使用下标将元素值修改为 undefined，`i in arr;`返回结果为 true。
    - `arr.length -=1;` //删除尾部元素
    - `arr.pop();` //删除尾部元素
    - `arr.shift();` //删除头部元素
- **数组迭代**
  - for 循环
    ```
    var i = 0, n = 10;
    var arr = [1, 2, 3, 4, 5];
    for (; i < n; i++) {
      console.log(arr[i]);
    }
    ```
  - for in 循环
    - 数组也是对象，也有原型。for in 循环会显示 Array.prototype 上的属性，可以用 hasOwnProperty 过滤。
    - for in 不保证数组顺序。在意顺序需使用上面的 for 循环。
    ```
    for (i in arr) {
      console.log(arr[i]);
    }
    ```

### _二维数组和稀疏数组（5-2）_

- 二维数组遍历使用嵌套 for 循环
- 稀疏数组：并不含有从 0 开始的连续索引。一般 length 属性值比实际元素个数大。操作时需要做好判断。
  ```
  var arr1 = [undefined];
  var arr2 = new Array(1);
  0 in arr1; //true.有元素，值为undefined
  0 in arr2; //false.元素不存在
  ```
  ```
  arr1.length = 100;
  arr1[99] = 123;
  99 in arr1; //true.
  98 in arr1; //false
  ```
  ```
  var arr = [,,];
  0 in arr; //false.逗号分隔方式创建的也是稀疏数组。
  ```

### _数组方法（5-3 5-4）_

- **Array.prototype.join** 将数组转化为字符串
  ```
  var arr = [1,2,3];
  arr.join(); //"1,2,3" 不加参数默认为逗号
  arr.join("_"); //"1_2_3"
  ```
  - 应用：快速创建重复 n 次的字符串
  ```
  function repeatString(str, n){
    return new Array(n+1).join(str);
  }
  repeatString('a', 3);
  repeatString('Hi', 5);
  ```
- **Array.prototype.reverse** 将数组逆序. in-place
  ```
  var arr = [1,2,3];
  arr.reverse(); //[3,2,1]
  arr; //[3,2,1]。修改的是原数组。
  ```
- **Array.prototype.sort** 排序. in-place
  ```
  var arr = ["a","d","c","b"];
  arr.sort(); //["a", "b", "c", "d"]
  ```
  - 元素被转化为字符串后再排序
  - 修改原数组。在数组本身进行修改 in place operation。
    ```
    arr = [13, 24, 51, 3];
    arr.sort(); //[13, 24, 3, 51]
    arr; //[13, 24, 3, 51]
    ```
  - 如果按照数字大小排序，需要给 sort 传入比较函数
    ```
    arr.sort(function(a, b)){
      return a - b; // a < b升序
    }); // [3, 13, 24, 51]
    ```
    - 复杂结构排序
    ```
    arr = [{age:25},{age:39},{age:99}];
    arr.sort(funtion(a,b){
      return a.age - b.age;
    });
    arr.forEach(function(item){
      console.log('age',item.age);
    })
    ```
- **Array.prototype.concat** 数组合并
  ```
  var arr = [1,2,3];
  arr.concat(4,5); //[1,2,3,4,5]
  arr; //[1,2,3] 原数组未被修改
  ```
  - 数组和元素合并，数组将会只保留元素
  - 数组里还有数组的话，内部数组会被保留
  ```
  arr.concat([10,11],13); //[1,2,3,10,11,13]
  arr.concat([1,[2,3]]); //[1,2,3,1,[2,3]]
  ```
- **Array.prototype.slice** 返回数组片段
  ```
  var arr = [1,2,3,4,5];
  arr.slice(1,3); //[2,3].两个参数均为数组下标，[)，左闭右开区间。
  arr.slice(1); //[2,3,4,5].第一个参数数组下标到结尾。
  arr.slice(1,-1); //[2,3,4].负数索引表示从后往前的索引。-1表示最后一个元素。(1,-1)即表示从第2个元素开始到最后一个元素之前的元素。
  arr.slice(-4,-3); //[2]
  arr.slice(-3,-4); //[]
  ```
- **Array.prototype.splice** 数组拼接. in-place
  ```
  var arr = [1,2,3,4,5];
  arr.splice(2); //[3,4,5]
  arr; //[1,2] 原数组被修改
  ```
  ```
  arr = [1,2,3,4,5]
  arr.splice(2,2); // [3,4].第二个元素表示想要删除的元素的个数。
  arr; //[1,2,5]
  ```
  ```
  arr = [1,2,3,4,5]
  arr.splice(1,1,'a','b'); // [2].后面可以添加无限参数，在删除位置增加元素。
  arr; //[1,"a","b",3,4,5]
  ```