---
title: 前端知识点
layout: post
categories: ''
tags: ''
---
#### 2019.2.12

## |**页面布局**|

- 《前端跳槽面试必备技巧》（3-1 3-2 页面布局）
- 三栏布局题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为 300px，中间自适应。

### 解题思路

见 layout.html

### 知识点总结

六种布局方案的实现方式，关键点，导致的问题，解决方式，优缺点

**float**

- **实现方式**
  - 目前已知两种。
  1. 方式一：子元素全部左浮动，元素顺序左中右；
  2. 方式二：左元素左浮动，右元素右浮动，中间元素自动上顶，元素顺序左右中（顺序很重要，如果左中右的顺序会如何？）。
- **关键点**
  1. float 后的元素具有包裹性，如果不给定宽度，则元素宽度由内部内容决定。
  2. float 后的元素脱离文档流，之后的元素起始位置会覆盖 float 元素，但之后元素里面的内容会让出 float 元素从而不被遮挡。
  3. 如果所有子元素都 float，会导致父元素高度塌陷问题，进而导致父元素后面的元素的 margin 问题等。需清除浮动。具体方式：
     - position 不为 static 或 relative
     - float 不为 none
     - overflow 不为 visible，可为 auto,scroll,hidden
     - display 为 inline-block,table-cell,table-caption
- **优缺点**
  - 优点：浏览器兼容性好
  - 缺点：？

**inline-block**

- **实现方式**
  - 子元素全部 inline-block，左右元素宽度 300px，中间元素 calc
- **关键点**
  - 注意解决子元素之间因代码空格换行导致的间距问题，父元素 font-size 设置为 0，子元素恢复 font-size
- **导致问题及解决方式**
  - 垂直居中问题,中间部分元素垂直方向位置：内部内容底部和两侧元素底部对齐？？？
- **优缺点**

### 待解决问题

1. float 的深刻理解，清除浮动等
2. inline-block 垂直位置问题

---

#### 2019.2.13

## |**CSS 盒模型**|

- 《前端跳槽面试必备技巧》（3-3 3-4 CSS 盒模型）
- 题目：解释 CSS 盒模型。

### 解题思路

标准模型和 IE 模型

### 知识点总结

啥

**inline-block**

- **实现方式**
- **关键点**
- **导致问题及解决方式**
- **优缺点**

### 待解决问题

---

## |**DOM 事件**|

- 《前端跳槽面试必备技巧》（3-6 3-7 DOM 事件）
- 题目：

---

## |**类型转换**|

- 《前端跳槽面试必备技巧》（3-8 类型转换）
- 题目：

---

#### 2019.2.14

## |**对象与原型**|

> imooc 《javascript 深入浅出》 （4-1 4-2 对象 原型链）。  
> 这两节讲的比较清楚，可以再看看。里面的图记住。

### _对象_

- **知识点**

  1. 对象中的属性是**无序的**，且每个属性都有一个**字符串**key
  2. 每个属性都有一些标签（writable enumerable configurable value），和 get/set 方法
  3. 每个对象有一个原型属性[[proto]]。下方代码中 obj.z 值为 1。访问对象中的属性时，如果没有在对象本身的属性中找到，会继续沿着原型链向上寻找。

  ```
  function foo(){}
  foo.prototype.z = 3;
  var obj = new foo();
  ```

  4. 对象还有一个[[class]]标签来表示它是哪个种类的，一个[[extensible]]来表示它是否允许增加新的属性
  5. 创建对象的方式
     - 对象字面量
     - new/原型链
     - Object.create()
  6. 原型链
     - delete obj.z 删除对象上的属性，不会影响原型链
  7. Object.create({})
     - 是系统内置函数，参数一般是对象。结果返回一个对象，并使对象的原型指向这个参数。

- **待解决问题**
  1. 什么时候输出 undefined 什么时候报错 not defined
  2. var ob = new function();
     ob 是对象？函数里面的行为会立即执行？
  3. 原型链指向问题。
  4. 对象属性检测。重新看看视频。

## |**对象与原型**|

> 《前端跳槽面试必备技巧》（3-10 3-11 原型链）

- **原型链**

  1. 创建对象有几种方法
  2. 什么是原型，构造函数，实例，原型链
     - 生成的对象就是一个实例
     - new 后面的函数是构造函数。构造函数也是普通函数，放在 new 后面就成了构造函数。构造函数使用 new 运算符来生成一个实例。
     - 原型链的指向，实例对象构造函数原型对象间的指向图记清楚。
     - 构造函数的 prototype 属性是用来将通用属性和方法传递给实例对象的。
     - 只有函数才有 prototype 属性，对象没有。因为对象不能作为构造函数被 new，所以不传递属性和方法，没必要有 prototype。
  3. instanceof 的原理
     - instanceof 的两边一边是实例对象的[[proto]]，另一边是构造函数的 prototype。
     - 只要是原型链上的构造函数，都会返回 true。
     - 如果要确认是否是直接构造函数，而不是原型链上的构造函数，需使用（实例对象.[[proto]].constructor == 构造函数）来判断。
  4. new 运算符

     - 步骤 1：创建一个空对象，空对象的\_\_proto\_\_指向构造函数的 prototype（即原型对象）
     - 步骤 2：运行构造函数，构造函数中的 this 指向新建的空对象（可以通过 this 调用原型对象上的属性和方法）。
     - 步骤 3：构造函数的 return 如果是基本类型或者没有 return，那么 return this，如果 return 为一个对象，那么就 return 对象。之前创建的空对象无效。
     - 用函数模拟 new 运算符：

     ```
     var newStep = function (func){
       var obj = Object.create(func.prototype);
       var r = func.call(obj);
       if(typeof r === 'object'){
         return r;
       }else{
         return obj;
       }
     }
     ```

---

#### 2019.2.15

## |**对象**|

> imooc 《javascript 深入浅出》 （第 4 章）

### _属性操作（4-3）_

- **读写对象属性**

  - 读：
    - obj.x(推荐使用)
    - obj.\['字符串 key'\](需要拼接等场景)
    - `for (p in obj){ console.log(obj[p]) }`。这种方式会把原型链上的属性遍历出来，并且顺序不确定。
    ```
    var obj = {a:2, b:5};
    for(var x in obj){
      console.log(x); // a, b
      console.log(obj[x]); // 2, 5
    }
    ```

- **属性读写-异常**

  - 读取不存在的属性会返回 undefined，读取或赋值给不存在的属性的属性会报错。

  ```
  var obj = {x:1};
  obj.y; // undefined
  var yz = obj.y.z; // TypeError: Cannot read property 'z' of undefined
  obj.y.z = 2; // TypeError: Cannot set property 'z' of undefined
  ```

  - 操作之前进行检测

  ```
  var yz;
  if(obj.y) {
    yz = obj.y.z;
  }
  ```

  - 巧用&&运算符规则

  ```
  var yz = obj && obj.y && obj.y.z;
  ```

- **删除属性**

  ```
  var person = {age: 28, title: 'fe'};
  delete person.age; // true
  delete person['title']; // true
  person.age; // undefined
  delete person.age; // true。重复删除不存在的属性，由于属性已经不存在所以仍返回true。
  ```

  ```
  delete Object.prototype; // false

  var descriptor = Object.getOwnPropertyDescriptor(Object, 'prototype'); // 获取对象中的所有标签，第一个参数是要查看的对象，第二个参数是要检测的属性。descriptor是属性的描述器对象。

  descriptor.configurable; // false。是否可配置。

  ```

  - var 定义的全局或局部变量不能被 delete，会返回 false。
  - 函数声明也不能被 delete。
  - 隐式定义变量可以被删除。不推荐。

  ```
  onNo = 1;
  window.ohNo; // 1;
  delete onNo; // true
  ```

  - evalue？里面定义的变量可以被删除。？这句话没听清，没细讲。

- **属性检测**

  ```
  // 构造一个对象并添加属性
  var cat = new Object;
  cat.legs = 4;
  cat.name = "Kitty";

  // in操作符来检测。会沿原型链向上查找。
  'legs' in cat; // true
  'abc' in cat; // false
  'toString' in cat; // true, inherited property.

  // hasOwnProperty('key')。只检查对象本身。
  cat.hasOwnProperty('legs'); // true
  cat.hasOwnProperty('toString'); // false

  // propertyIsEnumerable。检查属性是否可枚举。原型链上的大部分属性可枚举都是false，所以console对象时不会显示出来。
  cat.propertyIsEnumerable('legs'); // true
  cat.propertyIsEnumerable('toString'); // false

  ```

  - 自定义枚举标签

  ```
  Object.defineProperty(object name, 'property name', {enumerable: false(默认也是false), value: 1000}); // 通过这种方式定义的属性的enumerable如果不设置，默认为false。其他方式如字面量定义的对象属性默认enumerable是true。

  ```

  - 检测写法

  ```
  // 判断属性是否存在
  if(cat && cat.legs){
    cat.legs *= 2;
  }

  // undefined == null（两个等号下）
  if(cat.legs != undefined){
    // !== undefined or !== null
  }

  // 只处理不等于undefined的情况，使用严格等于
  if(cat.legs !== undefined){
    // only if cat.legs is not undefined
  }
  ```

- **属性枚举**
  - 不可枚举属性在对象 for in 遍历时不会显示
  - 只处理对象上的属性，不处理原型链上的属性，可增加 obj.hasOwnProperty(key)判断

### _get/set 方法（4-4）_

- 属性的 getter/setter 方法

```
var man = {
  weibo: '@Bosn',
  $age: null, // $开头不想暴露给外面
  get age() {
    if (this.$age == undefined) { // null值也会进入此分支
      return new Date().getFullYear() - 1988;
    } else {
      return this.$age;
    }
  },
  set age(val) {
    val = +val; // '+'可将值转化为数字类型
    if (!isNaN(val) && val > 0 && val < 150) {
      this.$age = +val;
    } else {
      throw new Error('Incorrect val =' + val);
    }
  }
}
console.log(man.age); //27
man.age = 100;
console.log(man.age); //100
man.age = 'abc'; //error:Incorrect val = NaN
```

- get/set 方法与原型链
  - 如果通过 obj.z 这种方式给对象属性赋值，如果该原型链上存在 z 的 get/set 方法，那么赋值不会成功，而是会走原型链的 get/set 方法。这种情况可通过 Object.defineProperty(obj, 'z', {value: 100, configurable: true});定义属性来解决。
  - 属性标签 writable 默认为 false，所以如果设置属性时不设置 writable，并且原型链上有这个属性，那么之后修改这个属性就不能成功。

### _属性标签（4-5）_

- 获取属性标签
  Object.getOwnPropertyDescriptor({pro: true}, 'pro');
  通过字面量方式定义的对象的 writable,enumerable,configurable 标签默认值均为 true。
- 设置属性标签
  ```
  Object.defineProperty(person, 'name',{
    writable: true/false
    enumerable: true/false // 设置false后，Object.keys(person);就不会显示
    configurable: true/false
    value: ''
  })
  ```
  设置多个属性,以及增加 get/set 方法
  ```
  Object.defineProperties(person, {
    title: {
      value: 'fe',
      enumerable: true
    },
    salary: {
      value: 50000,
      enumerable: true,
      writable: true
    },
    //...,
    luck: {
      get: function () {
        return Math.Random() > 0.5 ? 'good' : 'bad';
      }
    },
    promote: {
      set: function (level) {
        this.salary *= 1 + level * 0.1;
      }
    }
  })
  ```
- configurable 和 writable 为 true 或 false 的情况组合下属性的权限表格？？？

### _对象标签，对象序列化（4-6）_

- **对象标签**

  - 原型标签：\_\_proto\_\_ [[proto]]
  - class 标签：表示对象是哪个类型。可间接通过 Object.prototype.toString 来获取 class。
  - extensiable 标签表示对象是否可扩展。
    - Object.isExtensible(obj); //检测是否可扩展
    - Object.preventExtensions(obj); //禁止扩展
    - Object.seal(obj); //seal 方法会将对象的 configurable 标签设置为 false。Object.isSealed(obj);// 判断对象是否被 seal
    - Object.freeze(obj); //writable,configurable 都被设置为 false。Object.isFrozen(obj); //判断对象是否被冻结。
    - 上述方法均不会对原型链上的对象产生影响。如果改变原型链通过 Object.prototype.?（没听清）来拿到原型链的方法，来遍历原型链并进行操作。

- **序列化**

  - JSON.stringify(obj); //返回对象序列化后的字符串
    - 如果对象属性值为 undefined，那么序列化后的字符串中不会出现该属性。
    - 如果属性值为 NaN 或 Infinity，那么序列化时会被转化为'null'
    - 如果是 Date 类型，会被转化为 UTC 的格式
    ```
    obj = {val:undefined, a:NaN, b:Infinity, c:new Date()};
    // "{"a":null,"b":null,"c":"2019-02-15T09:33:35.728Z"}"
    ```
  - JSON.parse('{"x":1}'); //反序列化，将字符串转化为 js 对象。

    - 属性必须用双引号引起来。

  - 自定义序列化
    ```
    var obj = {
      x: 1,
      y: 2,
      o: {
        o1: 1,
        o2: 2,
        toJSON: function () {
          return this.o1 + this.o2;
        }
      }
    }
    JSON.stringify(obj); //"{"x":1,"y":2,"o":3}"
    ```
    - 'toJSON'属性，修改后面函数

- **其它对象方法**

  - toString()

    - `var obj = {x:1, y:2};`
    - `obj.toString();` // "[object Object]"
    - `obj.toString = function(){return this.x + this.y};` //自定义 toString()
    - `"Result" + obj;` //"Result 3", by toString.（加号运算符右侧 obj 会自动调用 toString()，所以返回 3）
    - `+obj;` //3, from toString

  - valueOf() 把对象转换为基本类型

    - `obj.valueOf = function(){return this.x + this.y + 100};` // 103, from valueOf`
    - `"Result" + obj;` // still "Result 103"

  - 当 toString()和 valueOf()都存在时，一元运算符'+'和作为拼接字符串使用的'+'，都会尝试把对象转换为基本类型，会先找 valueOf()。如果 valueOf()返回的结果是基本类型，那么就以 valueOf()的结果作为结果；如果 valueOf()不存在或者返回的是对象就会去找 toString()，如果不存在或者是返回对象，那么就会报错。
  - 很少自己调用 toString()和 valueOf(),做一些操作时，js 解释器会自动调用。

### _第 4 章总结_

- 对象的结构
- 创建对象
- 属性操作
- getter setter
- 属性标签 writable enumerable configurable value
- 对象标签 [[proto]] extensiable class
- 序列化
- 对象方法

---

#### 2019.2.16

## |**数组**|

> imooc 《javascript 深入浅出》 （第 5 章）

### _创建数组（5-1）_

- **数组概述**
  - 数组长度限制[0,2^23-1]
- **创建数组**
  - 字面量
    - 特殊情况，不推荐（可读性差，老 IE 兼容性问题）：
      - `var commasArr1 = [1,,2];`//1, undefined,2 如果有空位会被解释为 undefined
      - `var commasArr2 = [,,];`//undefined \* 2 最后一个多余的逗号会被忽略掉
  - Array 构造器 new Array()。new 关键字可以省略，var a = Array()也可。
    - 参数是数字。确定数组的长度。
    - 参数直接赋值。
- **数组元素读写**
  - 通过索引即数组下标来访问数组元素
  - 可以动态添加数组元素，进而改变数组长度 arr.length
  - `delete arr[0];arr[0];`//undefined。执行 delete 不会改变数组长度。
- **数组元素增删**
  - 数组长度是动态的，无需指定大小
  - 增加
    - `arr[i]`
    - `arr.push(x);` // 尾部增加元素
    - `arr[arr.length];` // 尾部增加元素
    - `arr.unshift(x);` // 头部增加元素
  - 删除
    - `delete arr[x];` //将 x 下标元素修改为 undefined。
      - delete 后，`i in arr;` 返回结果为 false,这里 i 是数组下标，而不是具体的元素值，使用元素值非数组下标会返回 false。
      - 如果不使用 delete，直接使用下标将元素值修改为 undefined，`i in arr;`返回结果为 true。
    - `arr.length -=1;` //删除尾部元素
    - `arr.pop();` //删除尾部元素
    - `arr.shift();` //删除头部元素
- **数组迭代**
  - for 循环
    ```
    var i = 0, n = 10;
    var arr = [1, 2, 3, 4, 5];
    for (; i < n; i++) {
      console.log(arr[i]);
    }
    ```
  - for in 循环
    - 数组也是对象，也有原型。for in 循环会显示 Array.prototype 上的属性，可以用 hasOwnProperty 过滤。
    - for in 不保证数组顺序。在意顺序需使用上面的 for 循环。
    ```
    for (i in arr) {
      console.log(arr[i]);
    }
    ```

### _二维数组和稀疏数组（5-2）_

- 二维数组遍历使用嵌套 for 循环
- 稀疏数组：并不含有从 0 开始的连续索引。一般 length 属性值比实际元素个数大。操作时需要做好判断。
  ```
  var arr1 = [undefined];
  var arr2 = new Array(1);
  0 in arr1; //true.有元素，值为undefined
  0 in arr2; //false.元素不存在
  ```
  ```
  arr1.length = 100;
  arr1[99] = 123;
  99 in arr1; //true.
  98 in arr1; //false
  ```
  ```
  var arr = [,,];
  0 in arr; //false.逗号分隔方式创建的也是稀疏数组。
  ```

### _数组方法（5-3 5-4）_

1. **Array.prototype.join** 将数组转化为字符串

```
var arr = [1,2,3];
arr.join(); //"1,2,3" 不加参数默认为逗号
arr.join("_"); //"1_2_3"
```

- 应用：快速创建重复 n 次的字符串

```
function repeatString(str, n){
  return new Array(n+1).join(str);
}
repeatString('a', 3);
repeatString('Hi', 5);
```

2. **Array.prototype.reverse** 将数组逆序. in-place

```
var arr = [1,2,3];
arr.reverse(); //[3,2,1]
arr; //[3,2,1]。修改的是原数组。
```

3. **Array.prototype.sort** 排序. in-place

```
var arr = ["a","d","c","b"];
arr.sort(); //["a", "b", "c", "d"]
```

- 元素被转化为字符串后再排序
- 修改原数组。在数组本身进行修改 in place operation。
  ```
  arr = [13, 24, 51, 3];
  arr.sort(); //[13, 24, 3, 51]
  arr; //[13, 24, 3, 51]
  ```
- 如果按照数字大小排序，需要给 sort 传入比较函数
  ```
  arr.sort(function(a, b)){
    return a - b; // a < b升序
  }); // [3, 13, 24, 51]
  ```
  - 复杂结构排序
  ```
  arr = [{age:25},{age:39},{age:99}];
  arr.sort(funtion(a,b){
    return a.age - b.age;
  });
  arr.forEach(function(item){
    console.log('age',item.age);
  })
  ```

4. **Array.prototype.concat** 数组合并

```
var arr = [1,2,3];
arr.concat(4,5); //[1,2,3,4,5]
arr; //[1,2,3] 原数组未被修改
```

- 数组和元素合并，数组将会只保留元素
- 数组里还有数组的话，内部数组会被保留

```
arr.concat([10,11],13); //[1,2,3,10,11,13]
arr.concat([1,[2,3]]); //[1,2,3,1,[2,3]]
```

5. **Array.prototype.slice** 返回数组片段

```
var arr = [1,2,3,4,5];
arr.slice(1,3); //[2,3].两个参数均为数组下标，[)，左闭右开区间。
arr.slice(1); //[2,3,4,5].第一个参数数组下标到结尾。
arr.slice(1,-1); //[2,3,4].负数索引表示从后往前的索引。-1表示最后一个元素。(1,-1)即表示从第2个元素开始到最后一个元素之前的元素。
arr.slice(-4,-3); //[2]
arr.slice(-3,-4); //[]
```

6. **Array.prototype.splice** 数组拼接. in-place

```
var arr = [1,2,3,4,5];
arr.splice(2); //[3,4,5]
arr; //[1,2] 原数组被修改
```

```
arr = [1,2,3,4,5]
arr.splice(2,2); // [3,4].第二个元素表示想要删除的元素的个数。
arr; //[1,2,5]
```

```
arr = [1,2,3,4,5]
arr.splice(1,1,'a','b'); // [2].后面可以添加无限参数，在删除位置增加元素。
arr; //[1,"a","b",3,4,5]
```

7. **Array.prototype.forEach** 数组遍历（for, for in, forEach）（此函数及以下函数均为 ES5 新增，IE9+）

- forEach 函数接受一个函数作参数，这个函数里面的三个参数分别是：值，索引，数组本身

```
var arr = [9, 8, 7, 6, 5];
arr.forEach(function(x, index, a) {
  console.log(x + "|" + index + "|" + (a === arr));
});
//9|0|true
//8|1|true
//7|2|true
//6|3|true
//5|4|true
```

8. **Array.prototype.map** 数组映射

- map 函数接受一个函数作参数，在遍历每一个元素时调用。

```
var arr = [1, 2, 3];
arr.map(function(x) {
  return x + 10;
}); //[11, 12, 13]
arr; //[1,2,3].原数组未被修改。
```

9. **Array.prototype.filter** 数组过滤

```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.filter(function(x, index) { //参数(元素值，索引)
  return index % 3 === 0 || x >= 8;
}); // [1, 4, 7, 8, 9, 10]
arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].原数组未被修改。
```

10. **Array.prototype.every & some** 数组判断

- every 每个元素均符合条件

```
var arr = [1, 2, 3, 4, 5];
arr.every(function(x) {
  return x < 10; // true
});

arr.every(function(x) {
  return x < 3; // false.遍历到不满足的地方就停止遍历，返回结果。
});
```

- some 任意一个元素符合条件

```
var arr = [1, 2, 3, 4, 5];
arr.some(function(x) {
  return x === 3; // true
});

arr.some(function(x) {
  return x === 100; // false
});
```

11. **Array.prototype.reduce & reduceRight**

- reduce 概念自己查。原数组未被修改。
- reduce 第二个参数可选，是传递给函数的初始值。

```
var arr = [1, 2, 3];
var sum = arr.reduce(function(x, y) {
  return x + y;
}, 0); // 6
arr; // [1,2,3]

var arr = [3, 9, 6];
var max = arr.reduce(function(x, y) {
  console.log(x + "|" + y);
  return x > y ? x : y;
});
// 3|9
// 9|6
max; // 9
```

- reduceRight 和 reduce 功能一样，但是从右到左遍历。

```
var arr = [3, 9, 6];
var max = arr.reduceRight(function(x, y) {
  console.log(x + "|" + y);
  return x > y ? x : y;
});
// 6|9
// 9|3
max; // 9
```

12. **Array.prototype.indexOf & lastIndexOf** 数组检索

- indexOf()从起始位置开始自左向右查找含起始位置元素右边的元素。
- lastIndexOf()从起始位置开始自右向左查找含起始位置元素左边的元素。
- 返回的都是元素下标，下标不会因为查找顺序和范围而有所变化。

```
var arr = [1, 2, 3, 2, 1];
arr.indexOf(2); // 1
arr.indexOf(99); // -1
arr.indexOf(1, 1); // 4
arr.indexOf(1, -3); // 4
arr.indexOf(2, -1); // -1
arr.lastIndexOf(2); // 3
arr.lastIndexOf(2, -2); // 3
arr.lastIndexOf(2, -3); // 1
```

13. **Array.isArray()** 判断是否为数组

- isArray() 是构造器对象上的函数。需要`Array.isArray([])`来调用。如果参数是数组对象就会返回 true。
- 其他判断是否是数组的方式：
  - [] instanceof Array; // true.构造器方式判断
  - ({}).toString.apply([]) === '[object Array]'; //true
  - [].constructor === Array; //true

### _数组小结_

- 数组和对象
  - 相同
    - 数组也是对象，也可以继承。继承了许多 Array.prototype 上的属性和方法。也继承了 Array.prototype 的原型 Object.prototype 的方法如 toString(),hasOwnProperty()等。
    - 数组是对象，对象不一定是数组。
    - 数组除了使用索引和提供的增删方法还增删属性，还可以当做对象用 arr.x=2 来添加删除属性。
  - 不同
    - 数组自动更新 length。
    - 按索引访问数组比访问一般对象属性快。由于 js 引擎的优化。
    - 数组对象继承 Array.prototype 上的大量数组操作方法。一般对象没有。
- 数组和字符串
  - 字符串也可以当做数组，按照数组索引去访问。str[1]返回第 2 个字符。
  - 字符串也有 length 属性。
  - 相互转化？

### _待解决问题_

- Array.\_\_proto\_\_指向？Array.isArray()
- arr.constructor === Array //true  
  Array.\_\_proto\_\_.constructor === Array //true  
  为什么两种方式都行
- ({}).toString.apply([]) === '[object Array]'; 这个不懂
- 数组和字符串的相互转化。

## |**函数和 this**|

> imooc 《javascript 深入浅出》 （第 6 章）

### _函数概述（6-1）_

- **概念**

  - 函数是一块 js 代码，被定义一次，可执行和调用多次。
  - JS 中的函数也是对象，可以像其他对象那样操作和传递。可以有属性和方法。所以常叫 JS 中的函数为函数对象。

    ```
    function fun() {
      return "a function";
    }
    fun.property = 5;
    fun.childFun = function() {
      return "a child function";
    };

    fun.hasOwnProperty("property"); //true;
    fun.childFun(); //"a child function"
    fun.property; //5
    fun.name; //"fun".'name'是函数中的一个自带属性。
    ```

  - 函数几个部分：函数名，参数列表，函数体。
  - 函数返回值依赖 return 语句，如果没有 return 语句，函数执行完后默认返回 undefined
  - 作为构造器的函数，即`new`调用的构造函数，如果没有 return 语句或者 return 的是基本类型，那么将返回`this`。如果 return 一个对象,则将该对象作为 `new` 操作的返回值。

### _函数声明与表达式（6-2）_

- **函数的创建方式**

  - **函数声明**
    ```
    function add(a, b) {
      //do sth;
    }
    ```
  - **函数表达式**

    ```
    // function variable,将一个函数赋值给一个变量
    var add = function(a, b) {
      //do sth
    };

    //IEF(Immediately Executed Function),立即执行函数表达式：将一个匿名函数用括号括起来，然后直接调用。
    (function() {
      // do sth
    })();

    // first-class function,将函数对象作为一个返回值。函数也是对象。
    return function() {
      //do sth
    };

    //NFE(Named Function Expression),命名式函数表达式。
    var add = function(a, b) {
      //do sth
    };
    ```

  - **Function 构造器(6-2)**

    - `var func = new Function('a','b','console.log(a+b);');`// 前面的参数是函数的形参，最后一个参数是函数体的逻辑。new 可以省略。
    - Function()构造的函数内部声明的变量依然是局部变量，不同的是，如果 Function()在函数内部声明了一个函数，那么这个 Function()可以访问到全局作用域，却不能访问到它所在的函数的作用域。

- **三种创建方式的异同**

- **变量&函数的声明前置**

  - 函数声明和函数表达式的区别：声明前置
  - 函数声明之前调用函数，会返回正确结果。因为函数声明(function add(a,b))会被提前到最前面。
  - 函数表达式声明前调用会报错`TypeError: undefined is not a function`。因为`var add`被提到最前面，但此时它的值是 undefined。

- **命名函数表达式(NFE)**
  - `var func = function nfe() {}; alert(func === nfe);`IE6~8 下会返回 false,IE9+下报错`"'nfe' is undefined"`
  - 调用匿名函数时，调用栈里显示`{anonymous function}`;调用命名函数时，调用栈里显示`Call Stack`,并显示命名函数的函数名。
  - 命名和匿名函数表达式都可以递归调用自己。

### _this（6-3）_

1. **全局的 this(浏览器)**

- this === window

2. **一般函数的 this(浏览器)**

```
function f1(){
  return this;
}
f1() === window; // true.在node下是global.

function f2(){
  "use strict";
  return this;
}
f1() === undefined; // true.
```

3. **作为对象方法的函数的 this**

- 函数作为对象中属性的值时，被称为对象中的方法

```
var o = {
  prop: 37,
  f:function(){
    return this.prop; // this指向对象o
  }
};
console.log(o.f()); // 37. (谁调用的函数，函数中的this就指向谁)
```

4. **对象原型链上的 this**

- p 的原型指向 o?
- 不管对象调用的是本身的方法，还是原型链上的方法，方法内部的 this 指向的都是对象本身(即它的调用者)。

5. **get/set 方法与 this**

- 为什么要存在 get/set，直接属性值写成一个函数如何？
- get/set 方法中的 this 指向对象本身

6. **构造器中的 this**

- 正常调用，this 会指向 window
- 如果使用 new,将函数作为构造器调用。详情查看 new 运算符步骤。

7. **call/apply 方法与 this**

- call/apply 将函数的 this 修改为参数
- call 和 apply 作用一样，传参时有一点区别
- 局部作用域中的变量不能覆盖 this 指向的全局作用域中的值
  ```
  var wjw = 's';
  function add5(c,d){
    var wjw = 'z'
    return this.wjw + c+d;
  }
  add5(3,2);// "s32"
  ```

8. **bind 方法与 this** ES5 新增

- this 修改为 bind()函数中的参数

### _函数属性 arguments（6-4）_

- **函数属性 & arguments**
  - `foo.length;`-形参个数
  - `foo.name;`-函数名
  - `arguments.length;`-实参个数，实际传了几个参数。arguments 在函数里也是一个特殊的对象，是一个类数组的对象。
    ```
    function foo(x, y, z) {
      arguments.length; //2
      arguments[0]; //1
      arguments[0] = 10;
      x; //change to 10;arguments[0]和x是绑定关系。如果严格模式下仍然是1.
      arguments[2] = 100;
      z; // still undefined.未传第3个参数，没有绑定关系
      arguments.callee === foo; //true.严格模式下禁止使用callee
    }
    foo(1, 2);
    foo.length; //3
    foo.name; //"foo"
    ```
- **apply/call 方法(浏览器)**

  - 第一个参数是想作为 this 的对象，如果不是对象，会被转成对象
  - call 传参是一个一个传，apply 的第二个参数是一个数组，数组每一项分别作为对应的参数传到函数里
  - 一般模式下，如果将 this 指向 null 或 undefined，那么会指向全局对象，浏览器里是 window，node 里是 global。严格模式下会指向 null 或 undefined。

  ```
  function foo(x, y) {
    console.log(x, y, this);
  }
  foo.call(100, 1, 2); //1,2,Number(100)
  foo.apply(true, [3, 4]); //3,4,Boolean(true)

  foo.apply(null); //undefined,undefined,window
  foo.apply(undefined); //undefined,undefined,window
  ```

- **bind 方法** ES5 新增

  - 改变函数的 this

  ```
  this.x = 9;
  var module = {
    x: 81,
    getX: function() {
      return this.x;
    }
  };
  module.getX(); // 81
  var getX = module.getX;
  getX(); // 9
  var boundGetX = getX.bind(module);
  boundGetX(); // 81
  ```

- **bind 与 currying**
  - bind 的另一个作用是：函数柯里化，把一个函数拆成多个单元。
  ```
  function add(a, b, c) {
    return a + b + c;
  }
  var func = add.bind(undefined, 100);
  func(1, 2); //103
  var fun2 = func.bind(undefined, 200);
  fun2(10); //310
  ```
- **bind 与 new**

  - new 下使用 bind 不会改变 this 指向。视频中分析代码过程可重复看。

  ```
  function foo() {
    this.b = 100;
    return this.a;
  }

  var func = foo.bind({ a: 1 }); // bind函数将this指向修改为参数{a:1}

  func(); //1 函数执行后，给this增加了一个属性b
  new func(); //{b:100} return的是基本类型，就会被忽略，返回的是this。a为undefined。
  ```

- **bind 方法模拟**

  - 听不懂？

---

#### 2019.2.17

## |**闭包和作用域**|

> imooc 《javascript 深入浅出》 （第 7 章）

### _闭包（7-1）_

- **闭包的例子**

  - js 中函数也是对象，函数也可以作为返回值，也可以作为传参，函数里也可以嵌套别的函数。

  ```
  function outer() {
    var localVal = 30;
    return function() { // 返回值是一个匿名函数
      return localVal;
    };
  }

  var func = outer();
  func(); //30 仍能访问到外层函数的局部变量，所以localVal不能被释放
  ```

- **闭包-无处不在**

  - 一个外层函数里面的内层函数可以访问到外层函数中的局部变量。外层函数执行后，内层函数仍有可能执行，所以仍有可能访问到外层函数中的变量，所以外层函数执行完后局部变量不能被回收。（不知道是否准确。）

- **闭包-常见错误之循环闭包**

  - 作用域 立即执行函数 闭包

- **闭包-封装**
- **闭包的概念**
  - 1
  - 1
- **闭包-小结**
  - 优点
    - 灵活和方便
    - 封装
  - 缺点
    - 空间浪费
    - 内存泄漏
    - 性能消耗

### _作用域（7-2）_

- **作用域**
  - 全局作用域
  - 没有块级作用域
    ```
    for (var item in { a: 1, b: 2 }) {
      console.log(item);
    }
    console.log(item); // item still in scope
    ```
  - 函数作用域，外部无法访问局部作用域
  - eval 作用域
- **作用域链**
  - 逐层向上级均可以访问到
  - Function('console.log(typeof i);');不可以访问到外部变量。
- **函数作用域封装**

  -

  ```
  (function() {
    //do sth
  })();

  !function() { // 或者加号
    //do sth
  }();
  ```

### _ES3 执行上下文（7-3）_

- 每次函数调用时，都会有一个对应的执行环境（执行上下文）execution context(EC)
- 全局执行上下文
- 函数重复调用时，每次调用的执行上下文均不同
- **概念-执行上下文**
  - 栈结构
- **概念-变量对象**
  - JS 解释器如何找到我们定义的函数和变量？变量对象(Variable Object,VO)是一个抽象概念中的"对象"，它用于存储执行上下文中的：1.变量 2.函数声明 3.函数参数
- **执行上下文与变量对象**
- **全局执行上下文（浏览器）**
  - 全局上下文里被初始化了 Math,String,isNaN 等这些东西，所以代码第一行就可以调用它们。
- **函数中的激活对象**
  - AO，不同的执行阶段下不同的东西
- **1. 变量初始化阶段** 视频可多重复看，能听懂，多熟悉
  1. 函数参数（若未传入，初始化该参数值为 undefined）
  2. 函数声明（若发生命名冲突，会覆盖）
  3. 变量声明（初始化变量值为 undefined，若发生命名冲突，会忽略）
- **2. 代码执行阶段**
- **测试题**

  ```
  alert(x);//输出1

  var x = 10;
  alert(x);//输出2
  x = 20;

  function x(){}
  alert(x);//输出3

  if(true){
    var a = 1;
  }else{
    var b = true;
  }

  alert(a);//输出4
  alert(b);//输出5
  ```

  - 答案：
    - 输出 1：function
    - 输出 2：10
    - 输出 3：20
    - 输出 4：1
    - 输出 5：undefined

## |**OOP**|

> imooc 《javascript 深入浅出》 （第 8 章）

### _概念与继承（8-1）_

- **概念**
  - OOP
- **基于原型的继承**
  - 每个函数，都内置 prototype 这样一个对象属性
- **prototype 属性与原型**
  - 每个 prototype 属性都有 constructor 和\_\_proto\_\_
  - prototype 的作用：在使用 new 来构造实例时，prototype 属性会用作 new 出来的对象的原型，即对象的\_\_proto\_\_
  - 问题：修改 Student.prototype.\_\_proto\_\_的指向，连带也修改了 constructor 的指向？

### _再谈原型链（8-2）_

- `var obj = Object.create(null);`此时 obj.\_\_proto\_\_为 undefined。所以并不是所有对象原型链上都有 Object.prototype
- 并不是所有函数对象都有 prototype 这个属性。bind 返回的函数没有。
  ```
  function abc(){};
  var binded = abc.bind(null);
  typeof binded; // "function"
  binded.prototype; // undefined
  ```

### _prototype 属性（8-3）_

- **改变 prototype**
  - 因为 js 中的原型也是普通对象，所以程序运行阶段也可以动态改变函数的 prototype。
  ```
  Student.prototype.x = 101;
  bosn.x; // 101
  ```
  - 如果改变 prototype 的引用，并不会修改已经创建了的实例对象。上面的 x 可以修改是因为修改的是之前 bosn 继承的那个对象。修改之后再 new 新的对象，属性值会继承修改后的 prototype。  
    即修改 prototype 属性可以影响已创建和新创建的实例，但给 prototype 赋值新的对象，不会修改已经创建的实例，但会影响后续创建的实例。
  ```
  Student.prototype = {y:2};
  bosn.y; // undefined
  bosn.x; // 101
  ```
- **内置构造器的 prototype**
  - 通过`Object.defineProperty()`来新增 prototype 上的属性，设置或使用 enumerable 等标签的默认值来防止之后遍历实例对象时会把新增属性输出等边际效应。
- **创建对象-new/原型链**
  - 重讲了最开始原型链的图形

### _instanceof（8-4）_

- **instanceof**

  - 对象 instanceof 函数构造器，判断右边的构造器的 prototype 属性是否出现在左边对象的原型链上。函数才有 prototype 属性。如果右边不是函数，会报错。如果左边不是对象会返回 false。
  - 不同 window 或 iframe 间的对象类型检测不能使用 instanceof

### _实现继承的方式（8-5）_

- `Student.prototype = Person.prototype;`// 不可以，这样赋值后，之后改变 Student.prototype，会影响 Person.prototype。（赋值，浅拷贝？不是这部分的知识。）
- `Student.prototype = new Person();`//new 出来一个指向 Person.prototype 的 Person 实例。但是这种方式，会运行构造函数，如果里面存在属性等，会被赋值给 Student 的原型链上，进而会被之后的实例继承。
- `Student.prototype = Object.create(Person.prototype);`ES5 新增

  - 模拟实现 Object.create()。原理：新建一个构造函数，将该构造函数的 prototype 指向参数（即想要继承的 prototype 对象），然后用该构造函数 new 出来一个实例返回。

  ```
  if(!Object.create){
    Object.create = function(proto){
      function F(){};
      F.prototype = proto;
      return new F();
    };
  }
  ```

## |**OOP（模拟重载 链式调用 模块化）**|

> imooc 《javascript 深入浅出》 （第 9 章）

- **模拟重载**
  - 判断参数类型然后给 this 赋值
- **调用子类方法**
  - `Person.call(this,name)` `Person.prototype.init.apply(this,arguments)`.call/apply 将调用它们的函数内部的 this 修改为第一个参数。执行语句没有 new，不涉及新对象，只是一个普通函数(Person()/init())的运行或是方法的调用。
- **链式调用**

  ```
  function ClassManager(){
    ClassManager.prototype.addClass = function(str){
      console.log('Class:'+str+'added.');
      return this; // new ClassManager()时，this 总是指向 ClassManager 的实例对象
    };

    var manager = new ClassManager(); // 此时 addCLass 方法没有执行。
    manager.addClass('classA').addClass('classB').addClass('classC'); // 执行 addClass 后，返回的 this 仍是最开始的 manager 对象，所以实现链式调用
    // Class:classA added.
    // Class:classB added.
    // Class:classC added.
  }
  ```

- **抽象类**
  - 在构造器里抛异常，防止抽象类直接被调用
- **defineProperty(ES5)**
- **模块化**

  - 模拟实现

  ```
  // 方式一
  var moduleA;
  moduleA = function() {
    var prop = 1;
    function func() {}
    return {
      func: func,
      prop: prop
    };
  }();

  // 方式二
  var moduleA;
  moduleA = new function() {
    var prop = 1;
    function func() {}
    this.func = func;
    this.prop = prop;
  };
  ```

### _探测器(9-2)_

- `!this instanceof DetectorBase` //检测是否通过 new 构造
- `DetectorBase.prototype.detect = function(){ throw new Error('Not implemented');}` //限制必须实现某方法不然报错
- 不运行方法时里面的 this？
- `Object.freeze()` //prevent from being altered

## |**Unity 和 VR**|

> bilibili 《Unity3D 零基础 VR 开发流程简介公开课-娱乐向解说》

- VR 是由两个摄影机来组成，左眼右眼看到不同的画面来看到立体的感觉。人的两只眼睛看到的画面有个位置差，两个画面叠加在一起经由大脑分析得出一个立体世界。单眼无法判断距离，很难将两根筷子头对在一起。
- 反畸变（四周拉伸部分还原）
- Unity3D 游戏 VR 化
  - unity 做一个 3D 游戏
  - （VR 分镜）导入 VR 运行设备(ep.暴风魔镜)的 unity 版 sdk
    - VR 游戏 SDK 对接以及发布流程演示
      - UI 调整
        - UI 分屏与 3D 化
        - VR 游戏中，不同对齐方式的 UI 需要不同的位置处理
      - 控制输入方式对接
        - 接入暴风魔镜自带方向控制
      - VR 模拟输入方式检查游戏性
- 发布安装包到移动平台
- 做游戏的技术栈
  - 建模 贴图 引擎 发布 ugui
  - 体素模型，很简单，再加一些简单动作
- 3D 眩晕
  - 运动模糊，眼睛看到的是一段时间发生的事情。
  - 游戏里每一帧是精确的时间点。一个个静止画面连起来的，中间的画面需要脑补，VR 里脑补范围太大，就会眩晕。减少眩晕方式是尽量减少画面中移动的东西。

---

#### 2019.2.19 垃圾

> imooc 《前端 JavaScript 面试技巧》 （第 1 章）

### _课程简介_

- **JS 基础部分三座大山**
  - 原型 原型链
  - 作用域 闭包
  - 异步 单线程
- **JS-WEB-API**
  - DOM 操作 Ajax 事件绑定
- **开发环境**
  - 版本管理 模块化 打包工具
- **运行环境**
  - 页面渲染 性能优化 前端安全
- **几个面试题**
  - JS 中使用 typeof 能得到的那些类型 //JS 变量类型
  - 何时使用===何时使用== //强制类型转换
  - window.onload 和 DOMContentLoaded 的区别 //浏览器渲染过程
  - 用 JS 创建 10 个\<a\>标签，点击的时候弹出来对应的序号 //作用域
  - 简述如何实现一个模块加载器，实现类似 require.js 的基本功能 //JS 模块化
  - 实现数组的随机排序 //JS 基础算法
- **思考**
  - 拿到一个面试题，你第一时间看到的是什么 -> 考点，考察的是哪块
  - 如何看待网上搜出来的永远也看不完的题海 -> 不变应万变，题目是变的知识是不变的
  - 如何对待接下来遇到的面试题 -> 题目到知识再到题目

## |**JS 基础知识**|

> imooc 《前端 JavaScript 面试技巧》 （第 2 3 章）

### _变量类型和计算_

- **题目**

  - JS 中使用 typeof 能得到的那些类型
    - 7 种，算 symbol
  - 何时使用===何时使用==
    - == 有类型转换，=== 没有类型转换
    - `a == null`是`a === null || a === undefined`的简写，jQ 源码中推荐写法
    - 除上述情况其它全部用三等
  - JS 中有哪些内置函数
    - 即数据封装类对象
    - 9 种：Object Array Boolean Number String Function Date RegExp Error
  - JS 变量按照存储方式区分为哪些类型，并描述其特点
    - 值类型和引用类型
  - 如何理解 JSON
    - 和 Math 一样是 JS 的内置对象。同时也是一种数据格式。
    - 常用 API：`str = JSON.stringify(obj)` `obj = JSON.parse(str)`

- **变量类型**
  - 值类型和引用类型（对象 数组 函数）
    - 将一个值类型的变量赋值给一个变量，复制的是一个值。
    - 讲一个引用类型变量赋值给一个变量，只是复制了一个引用。两个变量修改会相互影响，因为真正的值只是同样一份。
    - 为什么要这样：引用类型可以无限扩张属性，内存占用可能过大。
- **typeof 运算符** 一共有 6+1 种(symbol 课程没算)。能区分除 null 外的值类型和 function。
  - `typeof undefined` //"undefined"
  - `typeof 'abc'` //"string"
  - `typeof 123` //"number"
  - `typeof true` //"boolean"
  - `typeof {}` //"object"
  - `typeof []` //"object"
  - `typeof null` //"object"
  - `typeof console.log` //"function"
  - `typeof console.log()` //"undefined"
- **变量计算 - 强制类型转换**
  - 字符串拼接
    - `数字 + 数字` //数字
    - `数字 + 字符串` //字符串
  - == 运算符
    - `数字 == 字符串` //true _(转化为字符串)_
    - `0 == 空字符串` //true _(转化为 false)_
    - `null == undefined` //true _(转化为 false)_
  - if 语句
    - `if(true)` //true
    - `if(100)` //true
    - `if('')` //true
    - 另`if(x)`和`if(x == true)`不同。第一种变量不为 0,NaN,null,undefined,false,空字符串都会被处理成 true；第二种变量为布尔值且为 true 才符合条件。
  - **逻辑运算** ？？？
    - `10 && 0` //0 _(true && 0) 和 if 转化方式一样_
    - `'' || 'abc'` //'abc' _(false || 'abc') 和 if 转化方式一样_
    - `!window.abc` //true _(window.abc 是 undefined)_

### _构造函数_

- **题目**
  - 如何准确判断一个变量是数组类型
  - 写一个原型链继承的例子
  - 描述 new 一个对象的过程
  - zepto（或其他框架）源码中如何使用原型链
- **知识点**
  - 构造函数
  - 原型规则和示例
  - 原型链
  - instanceof

## |**作用域和闭包**|

- **题目**
  - 说一下对变量提升的理解
  - 说明 this 几种不同的使用场景
  - 创建 10 个\<a\>标签，点击的时候弹出来对应的序号
  - 如何理解作用域
  - 实际开发中闭包的应用
- **知识点**
  - 执行上下文
    - 全局（一段 script）:执行前先把变量定义 函数声明拿出来
    - 函数（函数）:执行前先把变量定义 函数声明 this arguments（函数参数的集合）
  - this
  - 作用域
  - 作用域链
  - 闭包

## |**异步和单线程**|

> imooc 《前端 JavaScript 面试技巧》 （第 4 章）

### _什么是异步_

- **题目**
  - 同步和异步的区别是什么？分别举一个同步和异步的例子
  - 一个关于 setTimeout 的笔试题
  - 前端使用异步的场景有哪些
- **知识点**
  - 什么是异步（对比同步）
    - 同步会阻塞后面的进程
    - 前端使用异步的场景
      - 定时任务：setTimeout setInterval
      - 网络请求：ajax 请求 动态\<img\>加载
      - 事件绑定
  - 前端使用异步的场景
  - 异步和单线程

---

#### 2019.2.20

## |**HTTP 协议类**|

> imooc 《前端跳槽面试必备技巧》（3-9）

### _HTTP 协议类_

- 基础理论类型，一面笔试出现概率大。有问有答即可。

- **题目**

  - HTTP 协议的主要特点
    - 简单快速：每个资源的 uri(统一资源标识符)是固定的，所以在 http 中处理很简单，输入 uri 即可访问某个资源。
    - 灵活：http 协议头部分中有一个数据类型。通过 http 头即可完成不同数据类型的传输。
    - 无连接：连接会断掉，不会一直保持。
    - 无状态：不保存连接者身份。
  - HTTP 报文的组成部分
    - 请求报文
      - 请求行：HTTP 方法, 页面地址, HTTP 协议, 版本（GET / HTTP/1.1）GET 后面的斜线表示访问地址的主页
      - 请求头：（Host Connection Cache-Control）
      - 空行：请求头和请求体的分界线
      - 请求体：
    - 响应报文
      - 状态行
      - 响应头
      - 空行
      - 响应体
  - HTTP 方法（记住 3-4 个）
    - GET POST PUT(更新资源) DELETE(删除资源) HEAD(获得报文首部)
  - POST 和 GET 的区别

    - GET 在浏览器回退时是无害的，而 POST 会再次提交请求
    - GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置
    - GET 请求在 URL 中传送的参数是有长度限制的（几 KB，拼接过长会被截断），而 POST 没有限制
    - 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制
    - GET 参数通过 URL 传递，POST 放在 Request body 中

    - GET 产生的 URL 地址可以被收藏，而 POST 不可以（可不记）
    - GET 请求只能进行 url 编码，而 POST 支持多种编码方式（可不记）
    - GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数（可不记）
    - GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息不会被保留（可不记）

  - HTTP 状态码
    - 1xx: 指示信息-表示请求已接收，继续处理
    - 2xx: 成功-表示请求已被成功接收
      - 200: 客户端请求成功
      - 206: 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它（请求了一部分，有范围的，如请求视频音频文件）
    - 3xx: 重定向-要完成请求必须进行更进一步的操作
      - 301: 永久重定向
      - 302: 临时重定向
      - 304: 服务器确认客户端的缓存没有新的修改，可直接使用
    - 4xx: 客户端错误-请求有语法错误或请求无法实现
      - 400: 客户端请求有语法错误，不能被服务器所理解
      - 401: 请求未经授权
      - 403: 资源禁止访问（如只能通过服务器访问的资源）
      - 404: 请求资源不存在
    - 5xx: 服务器错误-服务器未能实现合法的请求
      - 500: 服务器发生不可预期的错误，原来缓存的文档还可以继续使用
      - 503: 请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常
  - 什么是持久连接（重点）
    - 《图解 HTTP》也称 HTTP keep-alive，只要任意一端没有提出断开连接，则保持 TCP 连接状态。HTTP/1.1 才支持。减少了 TCP 连接的重复建立和断开所造成的额外开销。
  - 什么是管线化
    - 《图解 HTTP》同时并行发送多个请求，不需要一个请求发送等待响应后才能发送下一个请求。
    - 管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术
    - 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制
    - 初次创建连接时不应启动管线机制，因为服务器不一定支持 HTTP/1.1

## |**异步和性能**|

> 《你不知道的 JavaScript》（中卷 第二部分）

### _序_

- 回调是异步的基础。
- Promise 现在已经是 JavaScript 和 DOM 提供异步返回值的正式方法。
- 生成器

### _异步：现在与将来 第 1 章_

- 程序的一部分现在运行，另一部分将来运行，现在和将来之间的间隙中程序没有活跃执行。现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。

- **1.1 分块的程序**
  - js 程序是由多个块构成的。只有一个是现在执行，其余的则会在将来执行。最常见的块单位是函数。
  - **异步控制台**`console.log()`是由宿主环境添加到 js 中的。浏览器在后台异步处理控制台 I/O 能够提高性能。
- **1.2 事件循环**
  - JS 所有运行环境都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。
  - JS 引擎本身只是一个按需执行 JS 任意代码片段的环境，它并没有事件概念。
  - setTimeout()定时器的精度可能不高。只能保证回调函数不会在指定的时间间隔之前运行。
- **1.3 并行线程**
  - 异步：现在和将来的时间间隙
  - 并行：能够同时发生的事情
  - 由于 JS 的单线程特性，函数具有原子性，一旦开始执行就一定会执行完成，不会出现两个函数中的语句交替执行。
- ## **1.4 并发**
- **1.5 任务**
- **1.6 语句顺序**
- **1.7 小结**

---

#### 2019.2.21 (wang)

## |变量类型和计算|

- **题目**
  - js 中使用 typeof 能得到哪些类型?
  - 何时使用 === 何时使用 ==?
  - js 中有哪些内置函数?
  - js 按照变量存储方式分为哪些类型，并描述其特点?
  - 如何理解 JSON?
- **知识点**

  - 变量类型
    - 变量类型可分为值类型和引用类型。
    - 值类型包括 5 种基本数据类型：String,Number,Boolean,null,undefined.引用类型包括：Object,Array,Function.
    - 值类型与引用类型的区别：
      - 值类型：占用固定空间，保存在栈中；复制与保存的是值本身；使用 typeof 检测数据的类型；
      - 引用类型：占用空间不固定，保存在堆中；保存与复制的是指向对象的一个指针；使用 instanceof 检测数据类型。
  - typeof 运算符
    - 使用 typeof 检测数据类型，返回值有 6 种：string,number,boolean,undefined,object,function。
    - 使用 typeof 检测数据类型时 null、array、对象返回的都是 object。
  - 变量计算-自动类型转换

    - 会发生类型转换的几种情况：字符串拼接；== 运算符；if 语句；逻辑运算。
    - 逻辑运算或且非返回值规则：

      - 逻辑非（!）返回值都是 true 或 false;
      - 逻辑或（||）如果第一个值转为 boolean 为 true,则返回第一个值，为 false 则返回第二个值；
      - 逻辑与（&&）如果第一个值转为 boolean 为 true，则返回第二个值，为 false 则返回第一个值；
      - &&与||均为短路操作符，即第一个值能确定返回结果时，与第二个值无关，以上规则对 null,undefined,NaN 都适用

        ```
        var b = 100 + '10';//10010
        null == undefined; //true
        10 && 0 //10
        '' || 'abc' //'abc'
        !window.abc //false
        ```

  - 变量计算-强制类型转换
    - js 提供了转型函数：Number();parseInt();parseFloat;toString();String();Boolean().
    - Number()函数的类型转换规则：
      1. boolean 类型返回 0 或 1；
      2. number 类型返回本身；
      3. null 返回 0；
      4. undefined 返回 NaN;
      5. string 类型：忽略前导 0，只包括数字类型则返回数字；空字符串返回 0；其余返回 NaN；
      6. 如果是对象，则调用对象的 valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，再次依照前面的规则转换返回的字符串值。
    - `parseInt(string,radix)`函数类型转换规则：
      1. 只能输入数字或字符串，否则返回 NaN；
      2. 忽略前面的空格，第一个字符不是数字或“-”，直接返回 NaN；
      3. 忽略前面空格，如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止；
      4. 以 0x 开头按 16 进制解析，理论上以 0 开头按 8 进制解析，实际上以 0 开头会忽略 0 按 10 进制解析；
      ```
      parseInt('1234abc');//1234
      parsrInt('070');//70
      parsrInt('070',8);//56
      parseInt('22.5');//22
      parseFloat('22.5');//22.5
      parseInt('0x11');//17
      ```
    - parseFloat(string):除“.”被认为是有效字符外，其余规则与 parseInt()相同。
    - toString():除 null 与 undefined 之外其余对象均具有 toString 方法。
    - String()：null 返回"null",undefined 返回"undefined",其余返回 toString()方法的返回值。
    - Boolean():false、0、null、undefined、NaN 返回 false，其余返回 true。

- **解答**

  - 何时使用 === 何时使用 == ?
    - 推荐使用 jquery 中的写法：判断对象属性值为 null 或 undefined 时，使用==，写作 obj.a == null;其余情况均写===。
  - js 中有哪些内置函数?
    - 内置函数即数据封装类对象：Object,Array,Boolean,Number,String,Function,Date,RegExp,Error。
  - js 按照变量存储方式分为哪些类型，并描述其特点?
    - 按存储方式分为值类型和引用类型。见上。
  - 如何理解 JSON?
    - JSON 是一种数据格式，同时 JSON 与 Math 一样，是 js 中的内置对象，常用 api 包括：JSON.stringfy({a:10,b:20});JSON.parse('{"a":10}')# 异步和单线程

- **题目**
  - 同步和异步的区别分别是什么？分别举一个同步和异步的例子？
  - 一个关于 setTimeout()的笔试题？
  - 前端使用异步的场景有哪些？
- **知识点**

  - 异步运行机制

    - 参考链接：https://www.imooc.com/article/35252
    - 最基础的异步是 setTimeout 和 setInterval 函数。
    - JavaScript 是单线程的。单线程就意味着所有任务都要排队。为了提高 cpu 利用率，JavaScript 将所有任务分为两种：一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有等主线程任务执行完毕，"任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行。
    - 具体来说，异步运行机制如下：

      1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
      2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
      3. 一旦"执行栈"中的*所有同步* 任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
      4. 主线程不断重复上面的第三步。

      ```
      console.log("A");
      while(true){ }
      console.log("B");
      //"A" (不会输出"B")

      console.log("A");
      setTimeout(function(){
          console.log("B");
          },0);
      while(true){}
      //"A" (不会输出"B")
      ```

    - 会放入异步执行队列的语句及时机：

      1. setTimeout()与 setInterval();
      2. DOM 事件;
      3. ES6 中的 promise;
      4. Ajax 异步请求

      ```
      $.ajax({
      url：“xxxxx"，
      success:function (result){
          console.log("a")
          }
      })
      setTimeout(function(){
          console.log("b")
      },100)
      setTimeout(function(){
          console.log("c")
      })
      console.log("d");
      ```

      ![alt](https://user-gold-cdn.xitu.io/2018/5/30/163b13e4e10fc4b0?w=996&h=647&f=png&s=216461)

      ```
      for (var i = 0; i < 5; i++) {
          setTimeout(function() {
              console.log(i);
          }, 1000);
      }//5 5 5 5 5

      ```

      - 输出 0 1 2 3 4 的方式

      ```
      // 将var变为let
      for (let i = 0; i < 5; i++) {
          setTimeout(function() {
              console.log(i);
          }, 1000);
      }

      // 加立即执行函数
      for (var i = 0; i < 5; i++) {
          (function(i){
              setTimeout(function() {
                  console.log(i);
              }, 1000);
          })(i)
      }

      // 加闭包
      for(var i = 1;i < 5;i++){
          var a = function(){
              var j = i;
              setTimeout(function(){
                  console.log(j);
              },1000)
          }
          a();
      }
      ```

- **解答**
  - 同步与异步的区别？
    - 是否发生了阻塞。
  - 使用异步的场景？
    - 见上会放入异步执行队列的语句。另：动态加载图片（`img.onload=function(){}`）

## |**面向对象**|

> imooc 《前端跳槽面试必备技巧》（3-12）

### _面向对象_

- **面向对象类**
  - 类与实例
    - 类的声明
      - 构造函数模拟类
      - ES6 Class(ES6 待看？)
        ```
        class Animal{
          constructor(){
            this.name = 'name'
          }
        }
        ```
    - 生成实例
      - 如果类不需要传参，new实例时可以不写括号
  - 类与继承
    - 如何实现继承（继承的本质就是原型链）
    - 继承的几种方式
- ***

- **题目**

  - HTTP